var documenterSearchIndex = {"docs":
[{"location":"apireference/#Documentation","page":"API Reference","title":"Documentation","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Modules = [QuanticsGrids]","category":"page"},{"location":"apireference/#QuanticsGrids.DiscretizedGrid","page":"API Reference","title":"QuanticsGrids.DiscretizedGrid","text":"The DiscretizedGrid struct represents a grid for discretized continuous data. This is used for data that is originally continuous, but has been discretized for computational purposes. The grid contains values at specific, equally spaced points, which represent discrete approximations of the original continuous data.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#QuanticsGrids.InherentDiscreteGrid","page":"API Reference","title":"QuanticsGrids.InherentDiscreteGrid","text":"The InherentDiscreteGrid struct represents a grid for inherently discrete data. The grid contains values at specific, equally spaced points, but these values do not represent discretized versions of continuous data. Instead, they represent individual data points that are inherently discrete. The linear size of the mesh is base^R, where base defaults to 2.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#QuanticsGrids.InherentDiscreteGrid-Union{Tuple{Int64}, Tuple{d}} where d","page":"API Reference","title":"QuanticsGrids.InherentDiscreteGrid","text":"Create a grid for inherently discrete data with origin at 1\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids._digit_at_index-Tuple{Any, Any}","page":"API Reference","title":"QuanticsGrids._digit_at_index","text":"index, position and the result are one-based.\n\nbase: base index: The integer to look at. position=1: Specify the position of the digit to look at. 1 is the most significant (most left) digit. numdigits=8: Specify the number of digits in the number index.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.deinterleave_dimensions-Tuple{Any, Any}","page":"API Reference","title":"QuanticsGrids.deinterleave_dimensions","text":"deinterleave_dimensions(digitlist, d)\n\nReverses the interleaving of bits, i.e. yields digitlists for each dimension from a long interleaved digitlist. Inverse of interleave_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.fuse_dimensions-Tuple","page":"API Reference","title":"QuanticsGrids.fuse_dimensions","text":"fuse_dimensions(digitlists...)\n\nFuse d digitlists that represent a quantics index into a digitlist where each bit has dimension base^d. This fuses legs for different dimensions that have equal length scale (see QTCI paper).\n\nInverse of unfuse_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.fused_to_interleaved-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T<:Integer","page":"API Reference","title":"QuanticsGrids.fused_to_interleaved","text":"Converrt a fused qunaitcs representation to an unfused quantics representation\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grididx_to_origcoord-Tuple{QuanticsGrids.Grid{1}, Int64}","page":"API Reference","title":"QuanticsGrids.grididx_to_origcoord","text":"grid index => original coordinate\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grididx_to_origcoord-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, NTuple{d, Int64}}} where d","page":"API Reference","title":"QuanticsGrids.grididx_to_origcoord","text":"grid index => original coordinate\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grididx_to_quantics-Tuple{QuanticsGrids.Grid{1}, Int64}","page":"API Reference","title":"QuanticsGrids.grididx_to_quantics","text":"grid index => quantics\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grididx_to_quantics-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, NTuple{d, Int64}}} where d","page":"API Reference","title":"QuanticsGrids.grididx_to_quantics","text":"grid index => quantics\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.index_to_quantics!-Tuple{Any, Integer}","page":"API Reference","title":"QuanticsGrids.index_to_quantics!","text":"function index_to_quantics!(digitlist, index::Integer; base::Integer=2)\n\ndigitlist     base-b representation (1d vector)\nbase           base for quantics (default: 2)\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.index_to_quantics-Tuple{Integer}","page":"API Reference","title":"QuanticsGrids.index_to_quantics","text":"index_to_quantics(index::Integer; numdigits=8, base::Integer=2)\n\nDoes the same as index_to_quantics! but returns a new vector.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.index_to_quantics_fused!-Union{Tuple{D}, Tuple{AbstractVector{<:Integer}, NTuple{D, var\"#s12\"} where var\"#s12\"<:Integer}} where D","page":"API Reference","title":"QuanticsGrids.index_to_quantics_fused!","text":"index_to_quantics_fused!(digitlist::AbstractVector{<:Integer}, index::NTuple{D,<:Integer}; base::Integer=2) where {D}\n\nDoes the opposite of quantics_to_index_fused\n\nD\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.interleave_dimensions-Tuple","page":"API Reference","title":"QuanticsGrids.interleave_dimensions","text":"interleave_dimensions(digitlists...)\n\nInterleaves the indices of all digitlists into one long digitlist. Use this for quantics representation of multidimensional objects without fusing indices. Inverse of deinterleave_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.interleaved_to_fused-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Integer","page":"API Reference","title":"QuanticsGrids.interleaved_to_fused","text":"Converrt a unfused qunaitcs representation to an fused quantics representation\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.origcoord_to_grididx-Union{Tuple{N}, Tuple{DiscretizedGrid, NTuple{N, Float64}}} where N","page":"API Reference","title":"QuanticsGrids.origcoord_to_grididx","text":"Convert a coordinate in the original coordinate system to the corresponding grid index\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.origcoord_to_grididx-Union{Tuple{N}, Tuple{InherentDiscreteGrid, Union{Int64, NTuple{N, Int64}}}} where N","page":"API Reference","title":"QuanticsGrids.origcoord_to_grididx","text":"Convert a coordinate in the original coordinate system to the corresponding grid index\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.origcoord_to_quantics-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, Any}} where d","page":"API Reference","title":"QuanticsGrids.origcoord_to_quantics","text":"original coordinate => quantics\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quantics_to_grididx-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, Any}} where d","page":"API Reference","title":"QuanticsGrids.quantics_to_grididx","text":"quantics => grid index\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quantics_to_index-Union{Tuple{AbstractVector{<:Integer}}, Tuple{d}} where d","page":"API Reference","title":"QuanticsGrids.quantics_to_index","text":"function quantics_to_index(\n    digitlist::AbstractVector{<:Integer};\n    base::Val{B}=Val(2), dims::Val{d}=Val(1),\n    unfoldingscheme::Symbol=:fused\n)::NTuple{d,Int} where {B, d}\n\nConvert a d-dimensional index from fused quantics representation to d Integers.\n\nbase           base for quantics (default: 2)\nd           number of dimensions\ndigitlist     base-b representation\nunfoldingscheme    Unfolding scheme (fused or interleaved)\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quantics_to_index_fused-Union{Tuple{AbstractVector{<:Integer}}, Tuple{d}} where d","page":"API Reference","title":"QuanticsGrids.quantics_to_index_fused","text":"function quantics_to_index_fused(\n    digitlist::AbstractVector{<:Integer};\n    base::Val{B}=Val(2), dims::Val{d}=Val(1)\n)::NTuple{d,Int} where {B, d}\n\nConvert a d-dimensional index from fused quantics representation to d Integers.\n\nbase           base for quantics (default: 2)\nd           number of dimensions\ndigitlist     base-b representation\n\nSee also quantics_to_index.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quantics_to_origcoord-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, Any}} where d","page":"API Reference","title":"QuanticsGrids.quantics_to_origcoord","text":"quantics => original coordinate system\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quanticsfunction-Union{Tuple{d}, Tuple{T}, Tuple{Type{T}, QuanticsGrids.Grid{d}, Function}} where {T, d}","page":"API Reference","title":"QuanticsGrids.quanticsfunction","text":"Make a wrapper function that takes a bitlist as input\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.unfuse_dimensions-Tuple{Any, Any}","page":"API Reference","title":"QuanticsGrids.unfuse_dimensions","text":"unfuse_dimensions([base=Val(2)], digitlist, d)\n\nUnfuse up a fused digitlist with bits of dimension base^d into d digitlists where each bit has dimension base. Inverse of fuse_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#QuanticsGrids.jl-user-guide","page":"Home","title":"QuanticsGrids.jl user guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuanticsGrids","category":"page"},{"location":"","page":"Home","title":"Home","text":"This library provides utilities for interpolations of functions in the quantics TCI / quantics tensor train (QTT) format.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following will install QuanticsGrids.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"QuanticsGrids.jl\")","category":"page"},{"location":"#Definition","page":"Home","title":"Definition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We first introduce a B-base presentation (B=2 3 4 cdots). To avoid confusing, we will use the 1-based indexing of Julia below. We represent a positive integer X(ge 1) as","category":"page"},{"location":"","page":"Home","title":"Home","text":"X= sum_i=1^R (x_i-1) times B^R-i+1 + 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"where x_i is either 1 or 2 and R is the number of digits. In this library, the B-base representation of X is represented by the vector","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_1 cdots x_R","category":"page"},{"location":"","page":"Home","title":"Home","text":"This library supports two unfolding schemes (interleaved and fused representations) for handling multiple variables. As an example, we consider three variables X, Y and Z. Their B-base representations are given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_1 cdots x_R y_1 cdots y_R z_1 cdots z_R","category":"page"},{"location":"","page":"Home","title":"Home","text":"respectively. The interleaved representation of these variables reads","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_1 y_1 z_1 x_2 y_2 z_2 cdots x_R y_R z_R","category":"page"},{"location":"","page":"Home","title":"Home","text":"The fused representation is given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"alpha_1 alpha_2 cdots alpha_R","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"alpha_i = (x_i-1) + B(y_i-1) + B^2 (z_i-1) + 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"with","category":"page"},{"location":"","page":"Home","title":"Home","text":"1 le alpha_i le B^3","category":"page"},{"location":"","page":"Home","title":"Home","text":"This convention is consistent with the column major used in Julia: At each digit level i, the bit for x runs fastest. The fused representaion generalizes to any number of variables.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains two main functionalities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Low-level functions for converting betwen linear and quantics representations\nHigh-level interface for creating a grid","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal users will use the second high-level interface. We will describe its usage.","category":"page"},{"location":"#Discretized-grid","page":"Home","title":"Discretized grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiscretizedGrid can be used to discretize a d-dimensional space.","category":"page"},{"location":"#Creating-a-one-dimensional-grid","page":"Home","title":"Creating a one-dimensional grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can create a one-dimensional grid by discretizing x axis on 0 1) with R bits as","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QD\nxmin = 0.0\nxmax = 1.0\nR = 4\ngrid = QD.DiscretizedGrid{1}(R, xmin, xmax)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, DiscretizedGrid takes one parameter 1, which denotes the dimension of the grid. There are six functions for translating between different reprenstations: grididx (1-based linear index), quantics and origcoord (original coordiate, i.e., x). In origcoord_to_quantics and origcoord_to_grididx, if origcoord is out of the grid, the function returns the closest point in the grid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"quantics = fill(1, R)\norigcoord = 0.0\ngrididx = 1\n@assert QD.quantics_to_grididx(grid, quantics) == grididx\n@assert QD.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QD.grididx_to_quantics(grid, grididx) == quantics\n@assert QD.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QD.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QD.origcoord_to_grididx(grid, origcoord) == grididx\n\nquantics = fill(2, R)\norigcoord = 1-1/2^R\ngrididx = 2^R\n@assert QD.quantics_to_grididx(grid, quantics) == grididx\n@assert QD.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QD.grididx_to_quantics(grid, grididx) == quantics\n@assert QD.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QD.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QD.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optionally, one can include the end point grid_max in a grid as","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QD\nxmin = 0.0\nxmax = 1.0\nR = 4\ngrid = QD.DiscretizedGrid{1}(R, xmin, xmax; includeendpoint=true)\n\n@assert QD.grididx_to_origcoord(grid, 1) == xmin\n@assert QD.grididx_to_origcoord(grid, 2^R) == xmax","category":"page"},{"location":"#Creating-a-d-dimensional-grid","page":"Home","title":"Creating a d-dimensional grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A d-dimensional grid, where each axis is discretized with R bits, can be generated in a similar way as follows. As an option, you can choose the fused representation (:fused) or the interleaved representation (:interleaved).","category":"page"},{"location":"#fused-representation","page":"Home","title":"fused representation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QD\nxmin, xmax = 0.0, 1.0\nymin, ymax = 0.0, 1.0\nzmin, zmax = 0.0, 1.0\nR = 4\ngrid = QD.DiscretizedGrid{3}(R, (xmin,ymin,zmin), (xmax,ymax,zmax); unfoldingscheme=:fused)\n\nquantics = fill(1, R)\norigcoord = (0.0, 0.0, 0.0)\ngrididx = (1, 1, 1)\n@assert QD.quantics_to_grididx(grid, quantics) == grididx\n@assert QD.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QD.grididx_to_quantics(grid, grididx) == quantics\n@assert QD.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QD.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QD.origcoord_to_grididx(grid, origcoord) == grididx\n\n# Incrementing the least significant fused bits increments the $x$ index.\nquantics = vcat(fill(1, R-1), 2) # [1, 1, ..., 1, 2]\norigcoord = (1/2^R, 0.0, 0.0)\ngrididx = (2, 1, 1)\n@assert QD.quantics_to_grididx(grid, quantics) == grididx\n@assert QD.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QD.grididx_to_quantics(grid, grididx) == quantics\n@assert QD.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QD.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QD.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"#Interleaved-representation","page":"Home","title":"Interleaved representation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QD\nxmin, xmax = 0.0, 1.0\nymin, ymax = 0.0, 1.0\nzmin, zmax = 0.0, 1.0\nR = 4\ngrid = QD.DiscretizedGrid{3}(R, (xmin,ymin,zmin), (xmax,ymax,zmax); unfoldingscheme=:interleaved)\n\n# (x1, y1, z1, ...., xR, yR, zR)\nquantics = fill(1, 3R) # length is 3R\norigcoord = (0.0, 0.0, 0.0)\ngrididx = (1, 1, 1)\n@assert QD.quantics_to_grididx(grid, quantics) == grididx\n@assert QD.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QD.grididx_to_quantics(grid, grididx) == quantics\n@assert QD.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QD.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QD.origcoord_to_grididx(grid, origcoord) == grididx\n\nquantics = vcat(fill(1, 3R-3), [2, 1, 1]) # [1, 1, 1, ..., 2, 1, 1]\norigcoord = (1/2^R, 0.0, 0.0)\ngrididx = (2, 1, 1)\n@assert QD.quantics_to_grididx(grid, quantics) == grididx\n@assert QD.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QD.grididx_to_quantics(grid, grididx) == quantics\n@assert QD.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QD.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QD.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"#Inherent-discrete-grid","page":"Home","title":"Inherent discrete grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InherentDiscreteGrid can be used if the target space is discrete. InherentDiscreteGrid  has a very similar interface to DiscretizedGrid. We provide one example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QD\nR = 4\n# Grid: [0, 1, ..., 2^R-1]. The second argument (0,) specifies the origin.\ngrid = QD.InherentDiscreteGrid{1}(R, 0; step=1)\n\nquantics = fill(1, R)\norigcoord = 0\ngrididx = 1\n@assert QD.quantics_to_grididx(grid, quantics) == grididx\n@assert QD.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QD.grididx_to_quantics(grid, grididx) == quantics\n@assert QD.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QD.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QD.origcoord_to_grididx(grid, origcoord) == grididx\n\n\nquantics = fill(2, R)\norigcoord = 2^R-1\ngrididx = 2^R\n@assert QD.quantics_to_grididx(grid, quantics) == grididx\n@assert QD.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QD.grididx_to_quantics(grid, grididx) == quantics\n@assert QD.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QD.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QD.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"#Use-a-base-other-than-2","page":"Home","title":"Use a base other than 2","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When creating a grid, we may want to choose a different base other than 2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QD\nR = 4\nbase = 10\n# Grid: [0, 1, ..., 10^R-1]\ngrid = QD.InherentDiscreteGrid{1}(R, (0,); base=10)\n\nquantics = fill(base, R)\norigcoord = base^R-1\ngrididx = base^R\n@assert QD.quantics_to_grididx(grid, quantics) == grididx\n@assert QD.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QD.grididx_to_quantics(grid, grididx) == quantics\n@assert QD.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QD.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QD.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"#Create-a-function-that-takes-a-quantics-index-as-its-input","page":"Home","title":"Create a function that takes a quantics index as its input","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using QuanticsGrids.jl in combination with TensorCrossInterpolation.jl, one can wrap a function to be interpolated to make a fuction that takes a quantics index:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QD\nimport TensorCrossInterpolation as TCI\n\nR = 4\ngrid = QD.DiscretizedGrid{2}(R, (0.0, 0.0), (1.0, 1.0))\n\nf(x, y) = sin(x + y) # Function to be interpolated\n\ninitialpivots = [QD.origcoord_to_quantics(grid, (0.1, 0.1))] # at (x, y) = (0.1, 0.1)\nlocaldims = fill(2^2, R)\nfq = QD.quanticsfunction(Float64, grid, f) # fq takes an quantics index as an input\n\ntci, ranks, errors = TCI.crossinterpolate2(Float64, fq, localdims, initialpivots; tolerance=1e-8)","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"M. K. Ritter, Y. N. Fern√°ndez, M. Wallerberger, J. von Delft, H. Shinaoka, and X. Waintal, Quantics Tensor Cross Interpolation for High-Resolution, Parsimonious Representations of Multivariate Functions in Physics and Beyond, Phys. Rev. Lett. <b>132</b>, 056501 (2024)/arXiv:2303.11819.","category":"page"}]
}

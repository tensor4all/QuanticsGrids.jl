var documenterSearchIndex = {"docs":
[{"location":"apireference/#Documentation","page":"API Reference","title":"Documentation","text":"","category":"section"},{"location":"apireference/#QuanticsGrids.DiscretizedGrid","page":"API Reference","title":"QuanticsGrids.DiscretizedGrid","text":"The DiscretizedGrid struct represents a grid for discretized continuous data. This is used for data that is originally continuous, but has been discretized for computational purposes. The grid contains values at specific, equally spaced points, which represent discrete approximations of the original continuous data.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#QuanticsGrids.DiscretizedGrid-Union{Tuple{T}, Tuple{Int64, T, T}} where T<:Real","page":"API Reference","title":"QuanticsGrids.DiscretizedGrid","text":"Create a discretized grid for a 1D space\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.DiscretizedGrid-Union{Tuple{T}, Tuple{d}, Tuple{Int64, NTuple{d, T}, NTuple{d, T}}} where {d, T<:Real}","page":"API Reference","title":"QuanticsGrids.DiscretizedGrid","text":"Create a discretized grid for a d-dimensional space\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.InherentDiscreteGrid","page":"API Reference","title":"QuanticsGrids.InherentDiscreteGrid","text":"The InherentDiscreteGrid struct represents a grid for inherently discrete data. The grid contains values at specific, equally spaced points, but these values do not represent discretized versions of continuous data. Instead, they represent individual data points that are inherently discrete. The linear size of the mesh is base^R, where base defaults to 2.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#QuanticsGrids.InherentDiscreteGrid-Union{Tuple{Int64}, Tuple{d}} where d","page":"API Reference","title":"QuanticsGrids.InherentDiscreteGrid","text":"Create a grid for inherently discrete data with origin at 1\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids._digit_at_index-Tuple{Any, Any}","page":"API Reference","title":"QuanticsGrids._digit_at_index","text":"index, position and the result are one-based.\n\nbase: base index: The integer to look at. position=1: Specify the position of the digit to look at. 1 is the most significant (most left) digit. numdigits=8: Specify the number of digits in the number index.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.deinterleave_dimensions-Tuple{Any, Any}","page":"API Reference","title":"QuanticsGrids.deinterleave_dimensions","text":"deinterleave_dimensions(digitlist, d)\n\nReverses the interleaving of bits, i.e. yields digitlists for each dimension from a long interleaved digitlist. Inverse of interleave_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.fuse_dimensions-Tuple","page":"API Reference","title":"QuanticsGrids.fuse_dimensions","text":"fuse_dimensions(digitlists...)\n\nFuse d digitlists that represent a quantics index into a digitlist where each bit has dimension base^d. This fuses legs for different dimensions that have equal length scale (see QTCI paper).\n\nInverse of unfuse_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.fused_to_interleaved-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T<:Integer","page":"API Reference","title":"QuanticsGrids.fused_to_interleaved","text":"Convert a fused quantics representation to an unfused quantics representation\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grid_max-Tuple{DiscretizedGrid}","page":"API Reference","title":"QuanticsGrids.grid_max","text":"grid_max(g::DiscretizedGrid)\n\nReturns the grid point with maximal coordinate values.\n\nIf includeendpoint=false during creation of the grid, this value is dependent on grid resolution.\nIf includeendpoint=true during creation of the grid, this function is equivalent to upper_bound.\n\nThe return value is scalar for 1D grids, and a Tuple otherwise.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grid_max-Tuple{InherentDiscreteGrid}","page":"API Reference","title":"QuanticsGrids.grid_max","text":"grid_max(g::InherentDiscreteGrid)\n\nReturns the grid point with maximal coordinate values. The return value is scalar for 1D grids, and a Tuple otherwise.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grid_min-Tuple{DiscretizedGrid}","page":"API Reference","title":"QuanticsGrids.grid_min","text":"grid_min(g::DiscretizedGrid)\n\nReturns the grid point with minimal coordinate values. This is equivalent to lower_bound. The return value is scalar for 1D grids, and a Tuple otherwise.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grid_min-Tuple{InherentDiscreteGrid}","page":"API Reference","title":"QuanticsGrids.grid_min","text":"grid_min(g::InherentDiscreteGrid)\n\nReturns the grid point with minimal coordinate values. This is equivalent to grid_origin. The return value is scalar for 1D grids, and a Tuple otherwise.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grid_origin-Tuple{InherentDiscreteGrid}","page":"API Reference","title":"QuanticsGrids.grid_origin","text":"grid_origin(g::InherentDiscreteGrid)\n\nReturns the origin of the grid, as passed to the constructor during grid creation. The return value is scalar for 1D grids, and a Tuple otherwise.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grid_step-Union{Tuple{DiscretizedGrid{d}}, Tuple{d}} where d","page":"API Reference","title":"QuanticsGrids.grid_step","text":"grid_step(g::DiscretizedGrid)\n\nReturns the distance between adjacent grid points in each dimension. The return value is scalar for 1D grids, and a Tuple otherwise.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grid_step-Union{Tuple{InherentDiscreteGrid{d}}, Tuple{d}} where d","page":"API Reference","title":"QuanticsGrids.grid_step","text":"grid_step(g::InherentDiscreteGrid)\n\nReturns the distance between adjacent grid points in each dimension. The return value is scalar for 1D grids, and a Tuple otherwise.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grididx_to_origcoord-Tuple{QuanticsGrids.Grid{1}, Int64}","page":"API Reference","title":"QuanticsGrids.grididx_to_origcoord","text":"grid index => original coordinate\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grididx_to_origcoord-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, NTuple{d, Int64}}} where d","page":"API Reference","title":"QuanticsGrids.grididx_to_origcoord","text":"grid index => original coordinate\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grididx_to_quantics-Tuple{QuanticsGrids.Grid{1}, Int64}","page":"API Reference","title":"QuanticsGrids.grididx_to_quantics","text":"grid index => quantics\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.grididx_to_quantics-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, NTuple{d, Int64}}} where d","page":"API Reference","title":"QuanticsGrids.grididx_to_quantics","text":"grid index => quantics\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.index_to_quantics!-Tuple{Any, Integer}","page":"API Reference","title":"QuanticsGrids.index_to_quantics!","text":"function index_to_quantics!(digitlist, index::Integer; base::Integer=2)\n\ndigitlist     base-b representation (1d vector)\nbase           base for quantics (default: 2)\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.index_to_quantics-Tuple{Integer}","page":"API Reference","title":"QuanticsGrids.index_to_quantics","text":"index_to_quantics(index::Integer; numdigits=8, base::Integer=2)\n\nDoes the same as index_to_quantics! but returns a new vector.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.index_to_quantics_fused!-Union{Tuple{D}, Tuple{AbstractVector{<:Integer}, NTuple{D, var\"#s12\"} where var\"#s12\"<:Integer}} where D","page":"API Reference","title":"QuanticsGrids.index_to_quantics_fused!","text":"index_to_quantics_fused!(digitlist::AbstractVector{<:Integer}, index::NTuple{D,<:Integer}; base::Integer=2) where {D}\n\nDoes the opposite of quantics_to_index_fused\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.interleave_dimensions-Tuple","page":"API Reference","title":"QuanticsGrids.interleave_dimensions","text":"interleave_dimensions(digitlists...)\n\nInterleaves the indices of all digitlists into one long digitlist. Use this for quantics representation of multidimensional objects without fusing indices. Inverse of deinterleave_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.interleaved_to_fused-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Integer","page":"API Reference","title":"QuanticsGrids.interleaved_to_fused","text":"Convert an unfused quantics representation to an fused quantics representation\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.lower_bound-Tuple{DiscretizedGrid}","page":"API Reference","title":"QuanticsGrids.lower_bound","text":"lower_bound(g::DiscretizedGrid)\n\nReturns the grid point with minimal coordinate values, as passed to the constructor during grid creation. This is equivalent to grid_min. The return value is scalar for 1D grids, and a Tuple otherwise.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.origcoord_to_grididx-Union{Tuple{N}, Tuple{DiscretizedGrid, NTuple{N, Float64}}} where N","page":"API Reference","title":"QuanticsGrids.origcoord_to_grididx","text":"Convert a coordinate in the original coordinate system to the corresponding grid index\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.origcoord_to_grididx-Union{Tuple{N}, Tuple{InherentDiscreteGrid, Union{Int64, NTuple{N, Int64}}}} where N","page":"API Reference","title":"QuanticsGrids.origcoord_to_grididx","text":"Convert a coordinate in the original coordinate system to the corresponding grid index\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.origcoord_to_quantics-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, Any}} where d","page":"API Reference","title":"QuanticsGrids.origcoord_to_quantics","text":"original coordinate => quantics\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quantics_to_grididx-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, Any}} where d","page":"API Reference","title":"QuanticsGrids.quantics_to_grididx","text":"quantics => grid index\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quantics_to_index-Union{Tuple{AbstractVector{<:Integer}}, Tuple{d}} where d","page":"API Reference","title":"QuanticsGrids.quantics_to_index","text":"function quantics_to_index(\n    digitlist::AbstractVector{<:Integer};\n    base::Val{B}=Val(2), dims::Val{d}=Val(1),\n    unfoldingscheme::Symbol=:fused\n)::NTuple{d,Int} where {B, d}\n\nConvert a d-dimensional index from fused quantics representation to d Integers.\n\nbase           base for quantics (default: 2)\nd           number of dimensions\ndigitlist     base-b representation\nunfoldingscheme    Unfolding scheme (fused or interleaved)\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quantics_to_index_fused-Union{Tuple{AbstractVector{<:Integer}}, Tuple{d}} where d","page":"API Reference","title":"QuanticsGrids.quantics_to_index_fused","text":"function quantics_to_index_fused(\n    digitlist::AbstractVector{<:Integer};\n    base::Val{B}=Val(2), dims::Val{d}=Val(1)\n)::NTuple{d,Int} where {B, d}\n\nConvert a d-dimensional index from fused quantics representation to d Integers.\n\nbase           base for quantics (default: 2)\nd           number of dimensions\ndigitlist     base-b representation\n\nSee also quantics_to_index.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quantics_to_origcoord-Union{Tuple{d}, Tuple{QuanticsGrids.Grid{d}, Any}} where d","page":"API Reference","title":"QuanticsGrids.quantics_to_origcoord","text":"quantics => original coordinate system\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.quanticsfunction-Union{Tuple{d}, Tuple{T}, Tuple{Type{T}, QuanticsGrids.Grid{d}, Function}} where {T, d}","page":"API Reference","title":"QuanticsGrids.quanticsfunction","text":"Make a wrapper function that takes a bitlist as input\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.unfuse_dimensions-Tuple{Any, Any}","page":"API Reference","title":"QuanticsGrids.unfuse_dimensions","text":"unfuse_dimensions([base=Val(2)], digitlist, d)\n\nUnfuse up a fused digitlist with bits of dimension base^d into d digitlists where each bit has dimension base. Inverse of fuse_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#QuanticsGrids.upper_bound-Tuple{DiscretizedGrid}","page":"API Reference","title":"QuanticsGrids.upper_bound","text":"upper_bound(g::DiscretizedGrid)\n\nReturns the upper bound of the grid coordinates, as passed to the constructor during grid creation.\n\nIf includeendpoint=false during grid creation, this function returns a point that is one grid spacing beyond the last grid point (which can be obtained through grid_max).\nIf includeendpoint=true during grid creation, this function returns the point with maximal coordinate values. This is equivalent to grid_max.\n\nThe return value is scalar for 1D grids, and a Tuple otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#QuanticsGrids.jl-user-guide","page":"Home","title":"QuanticsGrids.jl user guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This library provides utilities for interpolations of functions in the quantics TCI / quantics tensor train (QTT) format.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following will install QuanticsGrids.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"QuanticsGrids\")","category":"page"},{"location":"#Definition","page":"Home","title":"Definition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We first introduce a B-base presentation (B=2 3 4 cdots). To avoid confusion, we will use the 1-based indexing of Julia below. We represent a positive integer X(ge 1) as","category":"page"},{"location":"","page":"Home","title":"Home","text":"X= sum_i=1^R (x_i-1) times B^R-i+1 + 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"where x_i is either 1 or 2 and R is the number of digits. In this library, the B-base representation of X is represented by the vector","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_1 cdots x_R","category":"page"},{"location":"","page":"Home","title":"Home","text":"This library supports two unfolding schemes (interleaved and fused representations) for handling multiple variables. As an example, we consider three variables X, Y and Z. Their B-base representations are given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_1 cdots x_R y_1 cdots y_R z_1 cdots z_R","category":"page"},{"location":"","page":"Home","title":"Home","text":"respectively. The interleaved representation of these variables reads","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_1 y_1 z_1 x_2 y_2 z_2 cdots x_R y_R z_R","category":"page"},{"location":"","page":"Home","title":"Home","text":"The fused representation is given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"alpha_1 alpha_2 cdots alpha_R","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"alpha_i = (x_i-1) + B(y_i-1) + B^2 (z_i-1) + 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"with","category":"page"},{"location":"","page":"Home","title":"Home","text":"1 le alpha_i le B^3","category":"page"},{"location":"","page":"Home","title":"Home","text":"This convention is consistent with the column major used in Julia: At each digit level i, the bit for x runs fastest. The fused representation generalizes to any number of variables.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains two main functionalities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Low-level functions for converting between linear and quantics representations\nHigh-level interface for creating a grid","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal users will use the second high-level interface. We will describe its usage.","category":"page"},{"location":"#Discretized-grid","page":"Home","title":"Discretized grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiscretizedGrid can be used to discretize a d-dimensional space.","category":"page"},{"location":"#Creating-a-one-dimensional-grid","page":"Home","title":"Creating a one-dimensional grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can create a one-dimensional grid by discretizing x axis on 0 1) with R bits as","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QG\nxmin = 0.0\nxmax = 1.0\nR = 4\ngrid = QG.DiscretizedGrid{1}(R, xmin, xmax)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, DiscretizedGrid takes one parameter 1, which denotes the dimension of the grid. There are six functions for translating between different representations: grididx (1-based linear index), quantics and origcoord (original coordinate, i.e., x). In origcoord_to_quantics and origcoord_to_grididx, if origcoord is out of the grid, the function returns the closest point in the grid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"quantics = fill(1, R)\norigcoord = 0.0\ngrididx = 1\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx\n\nquantics = fill(2, R)\norigcoord = 1-1/2^R\ngrididx = 2^R\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optionally, one can include the end point grid_max in a grid as","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QG\nxmin = 0.0\nxmax = 1.0\nR = 4\ngrid = QG.DiscretizedGrid{1}(R, xmin, xmax; includeendpoint=true)\n\n@assert QG.grididx_to_origcoord(grid, 1) == xmin\n@assert QG.grididx_to_origcoord(grid, 2^R) == xmax","category":"page"},{"location":"#Creating-a-d-dimensional-grid","page":"Home","title":"Creating a d-dimensional grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A d-dimensional grid, where each axis is discretized with R bits, can be generated in a similar way as follows. As an option, you can choose the fused representation (:fused) or the interleaved representation (:interleaved).","category":"page"},{"location":"#fused-representation","page":"Home","title":"fused representation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QG\nxmin, xmax = 0.0, 1.0\nymin, ymax = 0.0, 1.0\nzmin, zmax = 0.0, 1.0\nR = 4\ngrid = QG.DiscretizedGrid{3}(R, (xmin,ymin,zmin), (xmax,ymax,zmax); unfoldingscheme=:fused)\n\nquantics = fill(1, R)\norigcoord = (0.0, 0.0, 0.0)\ngrididx = (1, 1, 1)\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx\n\n# Incrementing the least significant fused bits increments the $x$ index.\nquantics = vcat(fill(1, R-1), 2) # [1, 1, ..., 1, 2]\norigcoord = (1/2^R, 0.0, 0.0)\ngrididx = (2, 1, 1)\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"#Interleaved-representation","page":"Home","title":"Interleaved representation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QG\nxmin, xmax = 0.0, 1.0\nymin, ymax = 0.0, 1.0\nzmin, zmax = 0.0, 1.0\nR = 4\ngrid = QG.DiscretizedGrid{3}(R, (xmin,ymin,zmin), (xmax,ymax,zmax); unfoldingscheme=:interleaved)\n\n# (x1, y1, z1, ...., xR, yR, zR)\nquantics = fill(1, 3R) # length is 3R\norigcoord = (0.0, 0.0, 0.0)\ngrididx = (1, 1, 1)\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx\n\nquantics = vcat(fill(1, 3R-3), [2, 1, 1]) # [1, 1, 1, ..., 2, 1, 1]\norigcoord = (1/2^R, 0.0, 0.0)\ngrididx = (2, 1, 1)\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"#Inherent-discrete-grid","page":"Home","title":"Inherent discrete grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InherentDiscreteGrid can be used if the target space is discrete. InherentDiscreteGrid has a very similar interface to DiscretizedGrid. We provide one example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QG\nR = 4\n# Grid: [0, 1, ..., 2^R-1]. The second argument (0,) specifies the origin.\ngrid = QG.InherentDiscreteGrid{1}(R, 0; step=1)\n\nquantics = fill(1, R)\norigcoord = 0\ngrididx = 1\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx\n\n\nquantics = fill(2, R)\norigcoord = 2^R-1\ngrididx = 2^R\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"#Use-a-base-other-than-2","page":"Home","title":"Use a base other than 2","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When creating a grid, we may want to choose a different base other than 2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QG\nR = 4\nbase = 10\n# Grid: [0, 1, ..., 10^R-1]\ngrid = QG.InherentDiscreteGrid{1}(R, (0,); base=10)\n\nquantics = fill(base, R)\norigcoord = base^R-1\ngrididx = base^R\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx","category":"page"},{"location":"#Create-a-function-that-takes-a-quantics-index-as-its-input","page":"Home","title":"Create a function that takes a quantics index as its input","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using QuanticsGrids.jl in combination with TensorCrossInterpolation.jl, one can wrap a function to be interpolated to make a function that takes a quantics index:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import QuanticsGrids as QG\nimport TensorCrossInterpolation as TCI\n\nR = 4\ngrid = QG.DiscretizedGrid{2}(R, (0.0, 0.0), (1.0, 1.0))\n\nf(x, y) = sin(x + y) # Function to be interpolated\n\ninitialpivots = [QG.origcoord_to_quantics(grid, (0.1, 0.1))] # at (x, y) = (0.1, 0.1)\nlocaldims = fill(2^2, R)\nfq = QG.quanticsfunction(Float64, grid, f) # fq takes an quantics index as an input\n\ntci, ranks, errors = TCI.crossinterpolate2(Float64, fq, localdims, initialpivots; tolerance=1e-8)","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"M. K. Ritter, Y. N. Fern√°ndez, M. Wallerberger, J. von Delft, H. Shinaoka, and X. Waintal, Quantics Tensor Cross Interpolation for High-Resolution, Parsimonious Representations of Multivariate Functions in Physics and Beyond, Phys. Rev. Lett. <b>132</b>, 056501 (2024)/arXiv:2303.11819.","category":"page"}]
}

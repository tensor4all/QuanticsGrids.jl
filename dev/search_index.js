var documenterSearchIndex = {"docs":
[{"location":"apireference/#Documentation","page":"API Reference","title":"Documentation","text":"","category":"section"},{"location":"apireference/#QuanticsGrids.DiscretizedGrid","page":"API Reference","title":"QuanticsGrids.DiscretizedGrid","text":"DiscretizedGrid{D}\n\nA discretized grid structure for D-dimensional grids with variable resolution, supporting efficient conversion between quantics, grid indices, and original coordinates. A DiscretizedGrid instance is intended to undergird a quantics tensor train with a specific index structure, as defined in the indextable field. For example, say indextable is [[(:a, 1), (:b, 2)], [(:a, 2)], [(:b, 1), (:a, 3)]], then the corresponding tensor train has 3 tensor cores:\n\n  a_1 b_2          a_2          b_1 a_3\n   |   |            |            |   |\n┌──┴───┴──┐    ┌────┴────┐    ┌──┴───┴──┐\n│         │    │         │    │         │\n│         │────│         │────│         │\n│         │    │         │    │         │\n└─────────┘    └─────────┘    └─────────┘\n\nThis object may be constructed with\n\njulia> grid = DiscretizedGrid((:a, :b), [[(:a, 1), (:b, 2)], [(:a, 2)], [(:b, 1), (:a, 3)]])\nDiscretizedGrid{2} with 8×4 = 32 grid points\n├─ Variables: (a, b)\n├─ Resolutions: (a: 3, b: 2)\n├─ Domain: unit square [0, 1)²\n├─ Grid spacing: (Δa = 0.125, Δb = 0.25)\n└─ Tensor train: 3 sites (dimensions: 4-2-4)\n\nand represents a 2^3 x 2^2 discretization of the unit square in the 2D plane (the x mark grid points):\n\n   1.0  ┌───────────────────────────────┐\n        │                               │\n        │                               │\n   0.75 x   x   x   x   x   x   x   x   │\n        │                               │\n        │                               │\nb  0.5  x   x   x   x   x   x   x   x   │\n        │                               │\n        │                               │\n   0.25 x   x   x   x   x   x   x   x   │\n        │                               │\n        │                               │\n   0.0  x───x───x───x───x───x───x───x───┘\n       0.0     0.25    0.5     0.75    1.0\n\n                        a\n\nIf something other than a unit square is desired, lower_bound and upper_bound can be specified. Also, bases different than the default base 2 can be used, e.g. base=3 for a ternary grid, or base=(2, 6) for per-variable bases. When passing a tuple, the base order matches variablenames.\n\nIn addition to the plain methods, there is a convenience layer for conversion from the original coordinates\n\njulia> origcoord_to_grididx(grid; a=0.5, b=0.25)\n(5, 2)\n\njulia> origcoord_to_quantics(grid; a=0.5, b=0.25)\n3-element Vector{Int64}:\n 4\n 1\n 1\n\nand also from grid indices\n\njulia> grididx_to_origcoord(grid; a=5, b=2)\n(0.5, 0.25)\n\njulia> grididx_to_quantics(grid; a=5, b=2)\n3-element Vector{Int64}:\n 4\n 1\n 1\n\nFor a simpler grid, we can just supply the resolution in each dimension:\n\njulia> boring_grid = DiscretizedGrid((3, 9))\nDiscretizedGrid{2} with 8×512 = 4096 grid points\n├─ Resolutions: (1: 3, 2: 9)\n├─ Domain: unit square [0, 1)²\n├─ Grid spacing: (Δ1 = 0.125, Δ2 = 0.001953125)\n└─ Tensor train: 12 sites (uniform dimension 2)\n\nIn this case, variable names are automatically generated as 1, 2, etc.\n\n\n\n\n\n","category":"type"},{"location":"#QuanticsGrids.jl-user-guide","page":"Home","title":"QuanticsGrids.jl user guide","text":"This library provides utilities for interpolations of functions in the quantics TCI / quantics tensor train (QTT) format.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The following will install QuanticsGrids.jl:\n\njulia> using Pkg; Pkg.add(\"QuanticsGrids\")","category":"section"},{"location":"#Definition","page":"Home","title":"Definition","text":"We first introduce a B-base presentation (B=2 3 4 cdots). To avoid confusion, we will use the 1-based indexing of Julia below. We represent a positive integer X(ge 1) as\n\nX= sum_i=1^R (x_i-1) times B^R-i+1 + 1\n\nwhere x_i is either 1 or 2 and R is the number of digits. In this library, the B-base representation of X is represented by the vector\n\nx_1 cdots x_R\n\nThis library supports two unfolding schemes (interleaved and fused representations) for handling multiple variables. As an example, we consider three variables X, Y and Z. Their B-base representations are given by\n\nx_1 cdots x_R y_1 cdots y_R z_1 cdots z_R\n\nrespectively. The interleaved representation of these variables reads\n\nx_1 y_1 z_1 x_2 y_2 z_2 cdots x_R y_R z_R\n\nThe fused representation is given by\n\nalpha_1 alpha_2 cdots alpha_R\n\nwhere\n\nalpha_i = (x_i-1) + B(y_i-1) + B^2 (z_i-1) + 1\n\nwith\n\n1 le alpha_i le B^3\n\nThis convention is consistent with the column major used in Julia: At each digit level i, the bit for x runs fastest. The fused representation generalizes to any number of variables.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"This package contains two main functionalities:\n\nLow-level functions for converting between linear and quantics representations\nHigh-level interface for creating a grid\n\nThe normal users will use the second high-level interface. We will describe its usage.","category":"section"},{"location":"#Discretized-grid","page":"Home","title":"Discretized grid","text":"DiscretizedGrid can be used to discretize a d-dimensional space.","category":"section"},{"location":"#Creating-a-one-dimensional-grid","page":"Home","title":"Creating a one-dimensional grid","text":"We can create a one-dimensional grid by discretizing x axis on 0 1) with R bits as\n\nimport QuanticsGrids as QG\nxmin = 0.0\nxmax = 1.0\nR = 4\ngrid = QG.DiscretizedGrid{1}(R, xmin, xmax)\n\nHere, DiscretizedGrid takes one parameter 1, which denotes the dimension of the grid. There are six functions for translating between different representations: grididx (1-based linear index), quantics and origcoord (original coordinate, i.e., x). In origcoord_to_quantics and origcoord_to_grididx, if origcoord is out of the grid, the function returns the closest point in the grid.\n\nExample:\n\nquantics = fill(1, R)\norigcoord = 0.0\ngrididx = 1\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx\n\nquantics = fill(2, R)\norigcoord = 1-1/2^R\ngrididx = 2^R\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx\n\nOptionally, one can include the end point grid_max in a grid as\n\nimport QuanticsGrids as QG\nxmin = 0.0\nxmax = 1.0\nR = 4\ngrid = QG.DiscretizedGrid{1}(R, xmin, xmax; includeendpoint=true)\n\n@assert QG.grididx_to_origcoord(grid, 1) == xmin\n@assert QG.grididx_to_origcoord(grid, 2^R) == xmax","category":"section"},{"location":"#Creating-a-d-dimensional-grid","page":"Home","title":"Creating a d-dimensional grid","text":"A d-dimensional grid, where each axis is discretized with R bits, can be generated in a similar way as follows. As an option, you can choose the fused representation (:fused) or the interleaved representation (:interleaved).","category":"section"},{"location":"#fused-representation","page":"Home","title":"fused representation","text":"import QuanticsGrids as QG\nxmin, xmax = 0.0, 1.0\nymin, ymax = 0.0, 1.0\nzmin, zmax = 0.0, 1.0\nR = 4\ngrid = QG.DiscretizedGrid{3}(R, (xmin,ymin,zmin), (xmax,ymax,zmax); unfoldingscheme=:fused)\n\nquantics = fill(1, R)\norigcoord = (0.0, 0.0, 0.0)\ngrididx = (1, 1, 1)\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx\n\n# Incrementing the least significant fused bits increments the $x$ index.\nquantics = vcat(fill(1, R-1), 2) # [1, 1, ..., 1, 2]\norigcoord = (1/2^R, 0.0, 0.0)\ngrididx = (2, 1, 1)\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx","category":"section"},{"location":"#Interleaved-representation","page":"Home","title":"Interleaved representation","text":"import QuanticsGrids as QG\nxmin, xmax = 0.0, 1.0\nymin, ymax = 0.0, 1.0\nzmin, zmax = 0.0, 1.0\nR = 4\ngrid = QG.DiscretizedGrid{3}(R, (xmin,ymin,zmin), (xmax,ymax,zmax); unfoldingscheme=:interleaved)\n\n# (x1, y1, z1, ...., xR, yR, zR)\nquantics = fill(1, 3R) # length is 3R\norigcoord = (0.0, 0.0, 0.0)\ngrididx = (1, 1, 1)\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx\n\nquantics = vcat(fill(1, 3R-3), [2, 1, 1]) # [1, 1, 1, ..., 2, 1, 1]\norigcoord = (1/2^R, 0.0, 0.0)\ngrididx = (2, 1, 1)\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx","category":"section"},{"location":"#Inherent-discrete-grid","page":"Home","title":"Inherent discrete grid","text":"InherentDiscreteGrid can be used if the target space is discrete. InherentDiscreteGrid has a very similar interface to DiscretizedGrid. We provide one example.\n\nimport QuanticsGrids as QG\nR = 4\n# Grid: [0, 1, ..., 2^R-1]. The second argument (0,) specifies the origin.\ngrid = QG.InherentDiscreteGrid{1}(R, 0; step=1)\n\nquantics = fill(1, R)\norigcoord = 0\ngrididx = 1\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx\n\n\nquantics = fill(2, R)\norigcoord = 2^R-1\ngrididx = 2^R\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx","category":"section"},{"location":"#Use-a-base-other-than-2","page":"Home","title":"Use a base other than 2","text":"When creating a grid, we may want to choose a different base other than 2.\n\nimport QuanticsGrids as QG\nR = 4\nbase = 10\n# Grid: [0, 1, ..., 10^R-1]\ngrid = QG.InherentDiscreteGrid{1}(R, (0,); base=10)\n\nquantics = fill(base, R)\norigcoord = base^R-1\ngrididx = base^R\n@assert QG.quantics_to_grididx(grid, quantics) == grididx\n@assert QG.quantics_to_origcoord(grid, quantics) == origcoord\n@assert QG.grididx_to_quantics(grid, grididx) == quantics\n@assert QG.grididx_to_origcoord(grid, grididx) == origcoord\n@assert QG.origcoord_to_quantics(grid, origcoord) == quantics\n@assert QG.origcoord_to_grididx(grid, origcoord) == grididx","category":"section"},{"location":"#Create-a-function-that-takes-a-quantics-index-as-its-input","page":"Home","title":"Create a function that takes a quantics index as its input","text":"When using QuanticsGrids.jl in combination with TensorCrossInterpolation.jl, one can wrap a function to be interpolated to make a function that takes a quantics index:\n\nimport QuanticsGrids as QG\nimport TensorCrossInterpolation as TCI\n\nR = 4\ngrid = QG.DiscretizedGrid{2}(R, (0.0, 0.0), (1.0, 1.0))\n\nf(x, y) = sin(x + y) # Function to be interpolated\n\ninitialpivots = [QG.origcoord_to_quantics(grid, (0.1, 0.1))] # at (x, y) = (0.1, 0.1)\nlocaldims = fill(2^2, R)\nfq = QG.quanticsfunction(Float64, grid, f) # fq takes an quantics index as an input\n\ntci, ranks, errors = TCI.crossinterpolate2(Float64, fq, localdims, initialpivots; tolerance=1e-8)","category":"section"},{"location":"#References","page":"Home","title":"References","text":"M. K. Ritter, Y. N. Fernández, M. Wallerberger, J. von Delft, H. Shinaoka, and X. Waintal, Quantics Tensor Cross Interpolation for High-Resolution, Parsimonious Representations of Multivariate Functions in Physics and Beyond, Phys. Rev. Lett. <b>132</b>, 056501 (2024)/arXiv:2303.11819.","category":"section"}]
}
